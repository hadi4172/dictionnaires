Documentation dotnet : https://bit.ly/3bIkFEQ
Créer une solution (structure de projets) : dotnet new sln -n "nomSolution"
Créer un nouveau projet .NET : dotnet new console|classlib|winforms[lib]|wpf[lib] -n "nomProjet" 
Ajouter projet à une solution dotnet sln "cheminSolution.sln" add "cheminProjet.csproj"
Lancer un projet .NET : dotnet watch run [-p "cheminProjet"]

Scaffolding avec Vs code : t.ly/BL1x            comparaison avec openclassrooms : t.ly/YwlG

Types : bit.ly/3ti6Xi4
Tableau de conversions de nombres : bit.ly/30Dltoc
Guillemets  (") servent à encadrer une chaîne de caractères 
Apostrophes (') servent à encadrer un caractère.

Afficher quelque chose : Console.WriteLine(variable);

Valeur par défaut
    type numérique : 0
    string : null 
    char : '\0'
    objet : null

Exemple enum
    enum Weather
    {
        Unknown,
        Sunny,
        Cloudy,
        Rainy
    }
    Weather todaysWeather = Weather.Sunny;   //Si vous ne faites que déclarer la variable, sans l'initialiser, elle prendra automatiquement la première valeur.

Opérateurs : comme Java sauf | et & qui sont les équivalents non lazy de || et && (tous les paramètres seront évalués)

Types nullables : ex: int? est un raccourci pour Nullable<int>  et indique que ce int peut prendre la valeur de null

Syntaxe méthode :
    typeDuRésultat nomDeLaMéthode(...arguments)
    {
        // Code à exécuter quand la méthode est appelée.
        return xxx;
    }

Passage par référence
//Lorsqu'un paramètre est passé par référence, il est lui-même utilisé dans le corps de la méthode.
    void ChangeInt(ref int myParameter)
    {
        myParameter = 5;
    }
appeler la fonction : ChangeInt(ref myInt);     //il faut vraiment écrire ref si cet argument est par référence dans la fonction, et il faut donner une variable initialisée

// imposer à la méthode d'assigner une valeur au paramètre
void ChangeInt(out int myParameter)
    {
        myParameter = 5;
    }
appeler la fonction : ChangeInt(out myInt);


Convertir string en int : bool success = int.TryParse("1234", out myInt);

Surcharge (Overload) : fonctionne comme en Java
Virtual : mot clé indiquant que la méthode peut être overridé chez un enfant de la classe // il est possible d'overrider une méthode non virtual avec new mais c'est déconseillé : t.ly/BNWq

Classes 
// Par défaut, champs et méthodes utilisent le modificateur private
//Exemple
    public class Person
    {
        private string m_name;      //attribut de la classe

        //getter et setter de m_name    (donc si on veut accéder à m_name de l'exterieur, on peut faire classePerson.Name)
        public string Name          //propriétés (ici des accesseurs/mutateurs)
        {
            get { return m_name; }          //on l'appelle comme ça : string userName = toto.Name;
            set { m_name = value; }         //on l'appelle comme ça : toto.Name = 10;
        }
        //peut être simplifié comme ça : public string Name { get; set; }       //pour un seul droit seulement : public string Name { get; private set; }
        // dans ce dernier cas, il n'y a pas besoin de créer un attribut m_name, on peut considérer qu'il y a une variable Name avec un getter et un setter
        // et pour accéder à cette variable à l'intérieur de la classe, on peut faire this.Name

        //constructeur
        public Person(string name, ushort age)
        {
            this.m_age = age;
            this.m_name = name;
            Console.WriteLine("Nouvelle personne créée. Cette personne s'appelle " + name + " et a " + age + " an(s).");
        }

        //destructeur   (détruit l'objet, permet de faire quelque chose à la destruction)
        ~Person()
        {
            Console.WriteLine("Objet détruit.");
        }

        public static int s_myStaticInt;

        public static void SayHi()
        {
            Console.WriteLine("Bonjour !");
        }
    }

    Exemple instanciation : Person toto = new Person("Toto", 10);
    
    //partial signifie que la classe est définie à plusieurs endroits. Ici vous ne voyez que ce que vous devez toucher. L'autre partie de la classe a été faite automatiquement et se charge du reste.
    // voir bit.ly/31LtifT et bit.ly/33qG43Q  pour plus de détails

    
Espace de noms (namespace) : à peu près l'équivalent des packages Java, voir bit.ly/3ESyY5Y    //Les noms de classe déclarés dans un espace de noms n'entrent pas en conflit avec les mêmes noms de classe déclarés dans un autre

Alias : using Utils = Company.Application.Utilities;        //nous pourrons écrire Utils.xxx plutôt que d'écrire Company.Application.Utilities.xxx

//voir bit.ly/31X5XYt pour pourquoi utiliser ça plutot qu'un tableau de tableaux
Tableaux à deux dimensions
    type[,] nom = new type[n, m];
    ou 
    double[,] myArray =
    {
        {0.1, 0.5},
        {1.3, 1.7}
    };

    // on y accède comme ceci : double myDouble = myArray[1, 1];

Tableaux de tableaux : fonctionnent comme en Java mais accepte cette syntaxe : int[][] myIntArrayArray = new int[5][];  //on peut définir par la suite la taille de chaque sous tableaux


Concaténation en string : string s = "M@teo" + 21;        //fonctionne sans problème
Formattage : string s = String.Format("{0} est remplacé par paramètre2 et {1} par paramètre3", "paramètre2", "paramètre3");      //spécifier type caractère : bit.ly/2Q3LYRJ
StringBuilder : 
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 1000; i++)  sb.Append(name);
    string fullString = sb.ToString();
    
Lire une entrée : string input = Console.ReadLine();

Commentaires spéciaux : Équivalent du Javadoc pour C#
// Exemple :
    /// <summary>
    /// Clean up any resources being used.
    /// </summary>
    /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>

Évènements
S'abonner à un évènement : this.m_myTestButton.EvenementVoulu += new System.EventHandler(this.methodeALancerLorsDuDeclenchement);
Exemple méthode d'évènement : 
    private void m_myTestButton_Click(object sender, EventArgs e) 
    {
        //sender est une référence vers l'objet qui a envoyé l'évènement. Exemple ↓
        Button senderButton = (Button)sender;
        senderButton.Text = "Bouton cliqué";
    }

Temps
Objet date avec date spécifiée : new DateTime(2009, 8, 8);
Aujourd'hui à 00:00:00 : DateTime.Today;
Maintenant heure locale: DateTime.Now;
Maintenant heure UTC : DateTime.UtcNow;
Décalage : DateTime.Today.AddDays(1);       //retourne la date de demain

Conversion de date en string
+---------------------+-----------------------------+---------------------+
| Méthode             | Description                 | Exemple             |
+=====================+=============================+=====================+
| ToLongDateString()  | date (long format)          | samedi 8 août 2009  |
| ToLongTimeString()  | heure (long format)         | 22:55:37            |
| ToShortDateString() | date (court format)         | 08/08/2009          |
| ToShortTimeString() | heure (court format)        | 22:55               |
| ToString()          | date + heure (court format) | 08/08/2009 22:55:37 |
+---------------------+-----------------------------+---------------------+

Timespan : intervalle de temps  //Exemple : TimeSpan exeDuration = DateTime.Now.Subtract(DateTime.Today.AddDays(-1));
MonthCalendar et DateTimePicker : bit.ly/3qJHZGz

Timer Windows:
Instanciation : Timer s_myTimer = new Timer();
Définir la durée d'une intervalle : s_myTimer.Interval = 1000;      //en milliseconde
Lancer un évenement à chaque intervalle x : s_myTimer.Tick += new EventHandler(s_myTimer_Tick);
Démarrer le Timer : s_myTimer.Start();
Arrêter le Timer : s_myTimer.Stop();
Vérifier si le Timer est en marche : Timer.Enabled;     /retourne un booléen

Exceptions
Exceptions courantes : bit.ly/3rNTrSK
Lancer une exception : throw new NotImplementedException("Le code n'a pas encore écrit !");     //Exemple
Intercepter une exception : ↓
    try
    {
        Console.Write("Entrez un nombre : ");
        int n = int.Parse(Console.ReadLine());
        Console.WriteLine(
            "100/nombre = {0}",
            100/n);
    }
    catch (DivideByZeroException dbzEx)     //C# permet aussi de ne pas déclarer une variable si on en a pas besoin, donc on aurait pu écrire catch(DivideByZeroException) seulement
    {
        Console.WriteLine("Erreur : division par zéro.");
    }
    catch (Exception ex)
    {
        Console.WriteLine(
            "Une autre exception a eu lieu : {0}.",
            ex.Message);
    }

Créer une exception :
    public class MyException : Exception            //: comme extends de Java
    {
        DateTime m_errorTime;
        static ushort s_errorNumber;

        public MyException() : base("Message par défaut de l'exception.") {
            m_errorTime = DateTime.Now;
            s_errorNumber++;
        }

        public MyException(string message) : base(message) {
            m_errorTime = DateTime.Now;
            s_errorNumber++;
        }

        public void DisplayError() {
            MessageBox.Show(base.Message,string.Format("Erreur n°{0} survenue à {1}.", s_errorNumber, m_errorTime.ToLongTimeString()), MessageBoxButtons.OK, MessageBoxIcon.Error);
        }
    }

Interface 
Créer une interface ↓
    interface IAnimal       //une interface est toujours publique
    {
        string Name { get; }
        void Move();
    }

Implémenter une interface ↓
    class Dog : IAnimal
    {
        private string m_name;

        public string Name {
            get { return m_name; }
        }

        public Dog(string name) {
            m_name = name;
        }
        
        public void Move() {
            Console.WriteLine("{0} bouge.", m_name);
        }
    }

Implémenter plusieurs interfaces : class SampleClass : IControl, ISurface
Si 2 interfaces ont un même attribut/méthode ↓
    class SampleClass : IControl, ISurface
    {
        public void Paint()
        {
            // Implémentation du Paint appelé par un objet SampleClass
            // (ou d'une interface qui n'a pas d'implémentation spécialement pour elle)
        }
        void IControl.Paint()
        {
            // Implémentation du Paint appelé par un objet IControl seulement
        }
        void ISurface.Paint()
        {
            // Implémentation du Paint appelé par un objet ISurface seulement
        }
    }

Structure
Essentiellement, ressemble beaucoup à une classe mais avec ces différences : 
* Struct ne peut pas avoir de constructeur par défaut (un constructeur sans paramètres) ni de destructeur.
* Les structs sont des types valeur et sont copiés lors de l'affectation tandis que les classes sont des types référence.
* Les structures peuvent être instanciées sans utiliser l'opérateur new.
* Une structure ne peut pas hériter d'une autre structure ou classe, et elle ne peut pas être la base d'une classe. Toutes les structures héritent directement de System.ValueType, qui hérite de System.Object.
* Struct ne peut pas être une classe de base. Ainsi, les types Struct ne peuvent pas être abstraits et sont toujours implicitement scellés.
* Les modificateurs abstraits et scellés ne sont pas autorisés et le membre de la structure ne peut pas être protégé ou protégé en interne.
* Les membres de fonction dans une structure ne peuvent pas être abstraits ou virtuels, et le modificateur override n'est autorisé que pour les méthodes override héritées de System.ValueType.
* Struct ne permet pas aux déclarations de champ d'instance d'inclure des initialiseurs de variables. Mais, les champs statiques d'une structure sont autorisés à inclure des initialiseurs de variables.
* Une structure peut implémenter des interfaces.
* Une structure peut être utilisée comme type nullable et peut se voir attribuer une valeur null.
Exemple ↓       //plus de détails : bit.ly/3s2Cnvp
................
    public struct Coords
    {
        public Coords(double x, double y)
        {
            X = x;
            Y = y;
        }

        public double X { get; init; }
        public double Y { get; init; }

        public override string ToString() => $"({X}, {Y})";
    }

    public static void Main()
    {
        var p1 = new Coords(0, 0);
        Console.WriteLine(p1);  // output: (0, 0)

        var p2 = p1 with { X = 3 };
        Console.WriteLine(p2);  // output: (3, 0)

        var p3 = p1 with { X = 1, Y = 4 };
        Console.WriteLine(p3);  // output: (1, 4)
    }
................


Fichiers
Lire et écrire dans un fichier texte : bit.ly/3tkD2G6
↓
................
    public static void WriteToFile(string content, string fileName)
    {
        try
        {
            File.WriteAllText (fileName, content);
            Console.WriteLine("Content written to " + fileName);
        }
        catch (IOException e)
        {
            Console.WriteLine("Could not write file to " + fileName + "\n" + e.ToString());
        }
    }
................

Requête HTTP ↓
................
    public static string GetContent(string url)
    {
        string content = "";

        try
        {
            using (WebClient webClient = new WebClient())
            {
                content = webClient.DownloadString(url);
            }
        }
        catch (WebException e)
        {
            Console.WriteLine("Cannot establish connection - " + e.ToString());
        }

        return content;
    }
................

Généricité
Créer méthode générique : static void WriteType<T, U>(T tObj, U uObj) {}
Appeler méthode générique : WriteType<int, string>(-1, "fooBarToto");
Classes génériques : fonctionnent globalement comme Java : bit.ly/3lgJ1J5

Collections 
Liste
Instanciation : List<typeVoulu> firstNameList = new List<typeVoulu>(tailleInitiale);
Obtenir nombre d'éléments : firstNameList.Count;
Ajouter des éléments : firstNameList.Add("Matt");
Enlever des éléments : firstNameList.Remove("Tim");     //retourne un booléen si la supression a réussi ou non
Enlever tous les éléments : firstNameList.Clear();

équivalent du map de JS en C# : string[] r = nums.Select(x => x + "a").ToArray();

Dictionnaires
Instanciation : Dictionary<typeCle, typeValeur> openWith = new Dictionary<typeCle, typeValeur>();
Ajouter des éléments : openWith.Add("txt", "notepad.exe");   // La méthode Add lance une exception si la clé existe déjà.
Accéder/Assigner à un élément : openWith["doc"] = "winword.exe";

Pile
Instanciation : Stack<typeVoulu> numbers = new Stack<typeVoulu>();
Ajouter un élément au sommet de la pile : numbers.Push(32);
Enlever le dernier élément de la pile : numbers.Pop();      //retourne l'élément enlevé
Récupérer le dernier élément de la pile sans le supprimer : numbers.Peek();

Foreach : foreach (string firstName in firstNameList){}
Foreach avec dictionnaire : bit.ly/3vpwJ5G
