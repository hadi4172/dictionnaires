SGBD (Système de Gestion de Base de Données) : logiciel permettant de manipuler les données d'une base de données. Peut être relationnel (sous forme de tables) ou non-relationnel.

Structure d'une base de donnée
---
Base de donnée
    Table1
        Champs1    Champs2    Champs3    ...
        Entrée1.1  Entrée1.2  Entrée1.3
        Entrée2.1  Entrée2.2  Entrée2.3
        ...
    Table2
    ...
---
Connexion à MySQL avec le terminal : mysql -h adresse -u user -pmotDePasse --default-character-set=utf8 --ex: mysql -h localhost -u root -proot --default-character-set=utf8
Déconnexion : quit

Annuler commande terminal : \c
Afficher avertissements : SHOW WARNINGS;    --doit être lancé directement après une erreur, sinon ne fonctionnera pas

Créer une sauvegarde SQL : mysqldump -u user -p --opt nom_de_la_base > nom_de_la_sauvegarde.sql         --va enregistrer une sauvegarde dans le dossier courant, donc utiliser cd avant
Charger une sauvegarde SQL : mysql nom_base < chemin_fichier_de_sauvegarde.sql  --si la BD a été supprimée, il faut la recréer avec CREATE DATABASE nom_base;

Créer un nouvel utilisateur : https://bityl.co/5LHA

Commentaires : --   --doit être suivi d'un espace au moin
String : Utiliser des apostrophes --ex: 'bateau'
Échappement des caractères spéciaux : MySQL utilise \ mais se renseigner pour chaque BD
Définir l'encodage : SET NAMES 'utf8';
Afficher avertissement MySQL : SHOW WARNINGS;

Types de données MySQL: https://bityl.co/5LJQ --TODO à retranscrire ici
Types courants : 
INT(size) : nombre entier ;
DOUBLE(size, d) : Le nombre total de chiffres est spécifié dans la taille. Le nombre de chiffres après la virgule décimale est spécifié dans le paramètre d
VARCHAR(size) : texte court (entre 1 et 255 caractères) ;
TEXT(size) : long texte (on peut y stocker un roman sans problème) ;
DATE(YYYY-MM-DD) : date (jour, mois, année).
TIME(hh:mm:ss) : Temps en heures minutes et secondes
TIMESTAMP(YYYY-MM-DD hh:mm:ss) : Date et temps

Types de données Oracle: Officiel: https://bit.ly/3ab36LD w3r: tinyurl.com/y3w665pn fr: tinyurl.com/y6xegcrp
NUMBER(taille[,decimales]) : Nombre entier ou flottant
VARCHAR2 (taille) : texte jusqu'à 2000 caractères
LONG(taille) : texte pouvant être très long
DATE 'YYYY-MM-DD' : date (jour, mois, année).
TIMESTAMP 'YYYY-MM-DD hh:mm:ss' : Date et temps

Opérateurs conditionnels : AND, OR, NOT

Créer une BD : CREATE DATABASE nom_base CHARACTER SET 'utf8';
Supprimer une BD : DROP DATABASE IF EXISTS nom_base;
Utiliser une BD : USE nom_base;         --pour spécifier la BD lors de la connexion à MySQL avec le terminal : mysql -u nom_utilisateur -p nom_base
Afficher les BD : SHOW DATABASES;
Afficher BD actuelle : SELECT DATABASE();   --Commande valide pour MySQL mais vérifier pour les autres
Afficher informations sur connexion : STATUS;

Exécuter des commandes SQL à partir d'un fichier : SOURCE monFichier.sql;      --on peut aussi utiliser \. monFichier.sql;

Préciser le moteur de table : ENGINE = INNODB;      --voir ici https://bityl.co/5LPO pour les autres moteurs --les moteurs sont une spécificité de MySQL qui permettent de gérer différemment les tables selon l'utilité que l'on en a

Créer une table ↓    --exemple
.............................
CREATE TABLE IF NOT EXISTS Animal (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,            --sur Oracle, au lieu d'AUTO_INCREMENT, il faut mettre GENERATED {ALWAYS}|{BY DEFAULT [ON NULL]} AS IDENTITY [START WITH valeurInitiale] [INCREMENT BY incrementation]
    espece VARCHAR(40) NOT NULL,
    sexe CHAR(1),
    commentaires TEXT,
    PRIMARY KEY (id)
)
ENGINE=INNODB;
.............................
Supprimer une table : DROP TABLE Nom_table;

Ajouter   colonne à une table : ALTER TABLE nom_table ADD COLUMN nom_colonne description_colonne;
Supprimer colonne d'une table : ALTER TABLE nom_table DROP COLUMN nom_colonne;
Modifier  colonne d'une table : ALTER TABLE nom_table MODIFY nom_colonne nouvelle_description;
Renommer et Modifier colonne d'une table : ALTER TABLE nom_table CHANGE ancien_nom nouveau_nom nouvelle_description;
Liste des utilisation d'ALTER : https://bityl.co/5LQQ

Vider contenu d'une table : TRUNCATE Nom_table;         --on peut aussi utiliser DELETE FROM Nom_table;

Afficher les noms des tables de la BD : SHOW TABLES;
Afficher les informations d'une certaine table : DESCRIBE Nom_table;
Afficher le contenu d'une certaine table : SELECT * FROM Nom_table;

Insérer des données dans une table ↓    --exemple
.............................
    INSERT INTO jeux_video(nom, prix, date_sortie) --pas nécessaire de lister les colonnes après jeux_video, mais cela permet de choisir l'ordre et fait qu'on n'est plus obligé de donner une valeur à chaque colonne
    VALUES('Battlefield 1942', 45, '2010-10-03 16:44:00'),
        ('PAC-MAN',          10, '1988-08-23 12:31:46');
.............................

Insérer des données à partir d'un fichier formaté ↓ 
.............................
    LOAD DATA [LOCAL] INFILE 'nom_fichier'
    INTO TABLE nom_table
    [FIELDS                     --colonnes
        [TERMINATED BY '\t']    --définit le caractère séparant les colonnes
        [ENCLOSED BY '']        --définit le caractère entourant les valeurs dans chaque colonne
        [ESCAPED BY '\\' ]      --définit le caractère d'échappement pour les caractères spéciaux
    ]
    [LINES                      --lignes
        [STARTING BY '']        --définit le caractère de début de ligne (vide par défaut)
        [TERMINATED BY '\n']    --définit le caractère de fin de ligne ('\n'  par défaut, mais les fichiers générés sous Windows ont souvent '\r\n')
    ]
    [IGNORE nombre LINES]       --permet d'ignorer un certain nombre de lignes.  Ex: si la 1ère ligne contient les noms des colonnes, Il suffit d'utiliser IGNORE 1 LINES.
    [(nom_colonne,...)];        --préciser le nom des colonnes présentes dans votre fichier. Attention à ce que les colonnes absentes acceptent NULL ou soient auto-incrémentées.


    Exemple ↓ 

    LOAD DATA LOCAL INFILE 'animal.csv'
    INTO TABLE Animal
    FIELDS TERMINATED BY ';' ENCLOSED BY '"'
    LINES TERMINATED BY '\n'
    (espece, sexe, date_naissance, nom, commentaires);
.............................

Sélectionner des données d'une table ↓
.............................
    SELECT [DISTINCT] ...colonnes_voulues        -- * pour tous les champs -- DISTINCT sert à éviter les doublons
    FROM nom_table                            
    [WHERE condition                             --pour filtrer les données reçues
    ORDER BY ...colonnes_par_lequel_ordonner     --ajouter DESC pour ordre décroissant  --tri sur plusieurs colonnes : se fera d'abord sur la première colonne, puis sur la seconde, etc.
    LIMIT nombre_de_lignes [OFFSET decalage];    --Pour renvoyer un nombre limité de résultats.  --syntaxe alternative propre à MySQL: LIMIT [decalage, ]nombre_de_lignes;
    ]


    Exemple ↓ 

    SELECT nom, possesseur, console, prix 
    FROM jeux_video 
    WHERE console='Xbox' OR console='PS2' 
    ORDER BY prix DESC 
    LIMIT 10 OFFSET 0                 --10 premières entrées
.............................

Supprimer des données d'une table: DELETE FROM nom_table WHERE condition;       --opération irréversible. Il est recommandé d'avoir une sauvegarde de la BD au cas ou on regretterais

Édition :  UPDATE nom_table SET col1 = val1, col2 = val2 ... WHERE condition;

Opérateurs de comparaisons particuliers :
Est égal à : =
Est égal à (valable pour NULL aussi) : <=>      --privilégier IS NULL ou IS NOT NULL
Intervalle : valeur BETWEEN val_inferieure AND val_supérieure   -- équivalent de valeur >= val_inferieure AND valeur <= val_supérieure   --peut s'utiliser avec nombres,textes et dates
Est inclus dans : valeur IN (...ensemble_de_possibilités);

Opérateurs de logique : AND OR XOR NOT

Jokers (Regex)
'%'  : qui représente n'importe quelle chaîne de caractères, quelle que soit sa longueur (y compris une chaîne de longueur 0) 
'_'  : qui représente un seul caractère.

Exemples :
'b%'  cherchera toutes les chaînes de caractères commençant par 'b'  ("brocoli", "bouli", "b").
'b_'  cherchera toutes les chaînes de caractères contenant deux lettres dont la première est'b'  ("ba", "bf", "b8").

Il faut échapper les caractères de Jokers (avec \) si on souhaite les rechercher

Exemples utilisant les Jokers : 
Exclure une chaîne de caractères : ... WHERE nom NOT LIKE '%a%';
Recherche avec sensibilité à la casse : ... WHERE nom LIKE BINARY '%Lu%';

Index ↓    --exemple lors de la création de la table
.............................
    CREATE TABLE nom_table (
        id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
        colonne1 INT NOT NULL,   
        nom VARCHAR(30),
        commentaires TEXT,
        espece VARCHAR(40) DEFAULT 'Inconnue' NOT NULL,
        PRIMARY KEY (id),
        INDEX ind_nom (nom(10)),            -- Crée un index sur sur les 10 premières lettres du nom -- un index permet d'accélérer les requêtes de séléctions mais ralentit ceux de modifications/insertions/suppressions
        UNIQUE ind_uni_col1 (colonne1),     -- Crée un index UNIQUE -- Avoir un index UNIQUE sur une colonne (ou plusieurs) permet de s'assurer que jamais deux fois la même valeur est insérée
        FULLTEXT ind_full_com (commentaires),   -- Crée un index FULLTEXT -- Un index FULLTEXT  est utilisé pour faire des recherches de manière puissante et rapide sur un texte. (TEXT/VARCHAR/CHAR)
        UNIQUE ind_uni_nom_espece (nom, espece)  -- Index sur le nom et l'espece -- détail index sur plusieurs colonnes : https://bityl.co/5MDj
    )
    ENGINE=INNODB;
.............................
Ajout d'index après création de table : CREATE INDEX [type index] nom_index ON nom_table (...colonnes);  --autre façon : ALTER TABLE nom_table ADD TYPE_D_INDEX nom_index (...colonnes); -- ... ADD PRIMARY KEY (...colonnes); pour clé primaire
Suppression d'un index : ALTER TABLE nom_table DROP INDEX nom_index;        --... DROP PRIMARY KEY; pour supprimer clé primaire

FULLTEXT :
Un mot peut être composé de lettres, chiffres, tirets bas (_) et apostrophes (')
Lorsque MySQL compare la chaîne de caractères que vous lui avez donnée et les valeurs dans votre table, il ne tient pas compte de tous les mots qu'il rencontre. Les règles sont les suivantes :
* les mots rencontrés dans au moins la moitié des lignes sont ignorés (règle des 50 %) ;
* les mots trop courts (moins de quatre lettres) sont ignorés ;
* les mots trop communs (en anglais, about, after, once, under, the…) ne sont également pas pris en compte.
Recherche naturelle ↓    --il suffit qu'un seul mot (mot exact) de la chaîne de caractères recherchée se retrouve dans une ligne pour que celle-ci apparaisse dans les résultats.
.............................
    SELECT *                                  -- Vous mettez évidemment les colonnes que vous voulez.
    FROM nom_table
    WHERE MATCH(...colonnes_voulues)          -- La (ou les) colonne(s) dans laquelle (ou lesquelles) on veut faire la recherche (index FULLTEXT correspondant nécessaire).
    AGAINST ('chaîne recherchée');            -- La chaîne de caractères recherchée, entre guillemets bien sûr.
.............................
Affichage de la pertinence de la recherche : SELECT *, MATCH(...colonnes_voulues) AGAINST ('chaîne recherchée') FROM nom_table;     --renvoie une table de pertinence qui est une valeur réelle supérieure à 0 si correspond à la recherche

Recherche booléenne ↓    --peut exiger que certains mots soient présents/absents, peut rechercher des parties de mot, pas de règle des 50 %, peut se faire sans FULLTEXT, résultat pas trié par pertinence par défaut
.............................
    ... --Un mot précédé par + : devra être présent, par - : devra être absent, un astérisque * en fin de mot indique qu'il peut finir de n'importe quelle manière
    AGAINST ('+petit* -prose' IN BOOLEAN MODE); 
.............................

Recherche avec extension de requête : Voir https://bityl.co/5MGj  --Les résultats d'une recherche naturelle sont utilisés pour faire en faire une seconde.

Clé primaire : c'est un index UNIQUE sur une colonne (ou plusieurs) qui ne peut pas être NULL
Clé étrangère: permet la vérification de l'intégrité de la BD. Elle doit être du même type que la clé primaire auquelle elle fait réference. Pas supporté par tous les moteurs de table (MyISAM ne supporte pas)
Ajout de clé étrangère à la création de la table: vers le bas de CREATE TABLE : CONSTRAINT nom_cle_etrangere FOREIGN KEY (...colonnes) REFERENCES table_référence(...colonnes_référence)
Ajout de clé étrangère après la création de la table: ALTER TABLE nom_table ADD CONSTRAINT nom_cle_etrangere FOREIGN KEY (...colonnes) REFERENCES table_référence(...colonnes_référence);
Suppression d'une clé étrangère : ALTER TABLE nom_table DROP FOREIGN KEY nom_cle_etrangere;

Contraintes :
Ajouter à la création d'une table ↓    --exemple
.............................
CREATE TABLE t1 (
  c1 int(11) DEFAULT NULL,
  c2 int(11) DEFAULT NULL,
  c3 VARCHAR(30) DEFAULT 'en_attente' NOT NULL,
  CONSTRAINT c1_c2_chk CHECK (((c1 + c2) < 9999)),
  CONSTRAINT c1_chk CHECK ((c1 > 0)),
  CONSTRAINT c3_chk CHECK (c3 IN ('en_attente', 'paye', 'recouvrement'))
) ENGINE=InnoDB
.............................
Ajouter après la création d'une table : ALTER TABLE nom_table ADD CONSTRAINT nom_contrainte CHECK (condition);

Définir un Alias : Exemple:  SELECT Espece.description AS description_espece        --peut aussi être utilisé pour écrire moin de code, ex : SELECT Espece.description AS d

Les jointures permettent d'associer plusieurs tables entre elles en ayant en commun les ID de l'autre table.
Jointure Interne ↓      -- Pour sélectionner seulement les données qui ont une correspondance entre les deux tables
.............................
    SELECT ...colonnes  
    FROM nom_table1   
    INNER JOIN nom_table2                      -- INNER explicite le fait qu'il s'agit d'une jointure interne, mais c'est facultatif
        ON colonne_table1 = colonne_table2     -- sur quelles colonnes se fait la jointure
        [AND ...]
    [WHERE ...                               
    ORDER BY ...                               -- les clauses habituelles sont bien sûr utilisables !
    LIMIT ...]


    Exemple ↓ 

    SELECT Espece.id AS id_espece,                  
        Espece.description AS description_espece,          
        Animal.nom AS nom_bestiole                   
    FROM Espece   
    INNER JOIN Animal
        ON Espece.id = Animal.espece_id
    WHERE Animal.nom LIKE 'Ch%';
.............................

Jointure Externe ↓   -- on veut toutes les lignes de la table de gauche (sauf restrictions dans le WHERE), même si certaines n'ont pas de correspondance avec une ligne de la table de droite.
.............................
    ...         -- Similaire à une jointure interne sauf
    FROM nom_table1                                                  -- Table de gauche
    RIGHT JOIN nom_table2                                            -- Table de droite
        ON Animal.race_id = Race.id                                  -- récupère tout le contenu de la table de gauche même si il n'existe pas de contenu dans la table de droite qui corresponde
    ...
.............................

Jointures avec USING : SELECT * FROM table1 [INNER | LEFT | RIGHT] JOIN table2 USING (colonneJ);    --Lorsque les colonnes qui servent à joindre les deux tables ont le même nom, vous pouvez utiliser la clause USING  au lieu de la clause ON
Jointures naturelles : SELECT * FROM table1 NATURAL JOIN table2;        --Permet de déterminer automatiquement quelles colonnes joindre quand elles ont le même nom dans les deux tables

-------------------------------------------------------- OLD

GROUP BY : utilisé avec fonction d'agrégat, permet de grouper les données selon un certain champs. ex: SELECT AVG(prix), console FROM jeux_video GROUP BY console  --le prix moyen des jeux pour chaque console
HAVING : filtrer les données après un regroupement. ex: SELECT AVG(prix) AS prix_moyen, console FROM jeux_video WHERE possesseur='Patrick' GROUP BY console HAVING prix_moyen <= 10

les fonctions scalaires : elles agissent sur chaque entrée.
les fonctions d'agrégat : elles agissent sur l'ensemble de la table pour retourner une valeur.

Exemple d'utilisation de fonction scalaire : SELECT UPPER(nom) AS nom_maj, prix, console FROM jeux_video          --retourne les champs transformés
Fonctions scalaires utiles :
UPPER : convertir en majuscules
LOWER : convertir en minuscules
LENGTH : compter le nombre de caractères
ROUND : arrondir un nombre décimal          --prends 2 paramètres : nomDuChamp et nbDeChiffresApresLaVirgule
autres fonctions numériques : https://bityl.co/3F77
autres fonctions sur chaines de caractères : https://bityl.co/3F79
autres fonctions sur dates et temps : https://bityl.co/3F9h

Exemple d'utilisations de fonction d'agrégat : SELECT AVG(prix) AS prix_moyen FROM jeux_video WHERE possesseur='Florent' --retourne une seule valeur --on ne peut mélanger une fonction d'agrégat avec d'autres champs
Fonctions d'agrégat utiles :
AVG : calculer la moyenne
SUM : additionner les valeurs
MAX : retourner la valeur maximale
MIN : retourner la valeur minimale
COUNT : compter le nombre d'entrées  --prends en argument * pour le nombre de rangées ou un nom de champs pour le nombre de rangées définies dans ce champ. Rajouter avant l'argument le mot clé DISTINCT pour avoir le nb d'arguments différents

Les différents types de dates
DATE : stocke une date au format AAAA-MM-JJ (Année-Mois-Jour) ;
TIME : stocke un moment au format HH:MM:SS (Heures:Minutes:Secondes) ;
DATETIME : stocke la combinaison d'une date et d'un moment de la journée au format AAAA-MM-JJ HH:MM:SS. Ce type de champ est donc plus précis ;
TIMESTAMP : stocke le nombre de secondes passées depuis le 1er janvier 1970 à 00 h 00 min 00 s ;
YEAR : stocke une année, soit au format AA, soit au format AAAA.

Il n'est pas recommandé d'appeler un champs "date"
Exemple de sélection avec un date : SELECT pseudo, message, date FROM minichat WHERE date >= '2010-04-02 00:00:00' AND date <= '2010-04-18 00:00:00'   --on peut aussi utiliser BETWEEN 'date' AND 'date

Exemple d'utilisation de fonctions de date : SELECT pseudo, message, DAY(date) AS jour FROM minichat
Fonctions utiles: 
NOW() : renvoie le datetime actuel          -- ex: INSERT INTO minichat(pseudo, message, date) VALUES('Mateo', 'Message !', NOW())
CURDATE() : renvoie la date actuelle
CURTIME() : renvoie le time actuel
DAY(), MONTH(), YEAR() : extraire le jour, le mois ou l'année
HOUR(), MINUTE(), SECOND() : extraire les heures, minutes, secondes
DATE_FORMAT() : formater une date       --ex: SELECT pseudo, message, DATE_FORMAT(date, '%d/%m/%Y %Hh%imin%ss') AS date FROM minichat  --autres params possibles : https://bityl.co/3FAQ
DATE_ADD() et DATE_SUB() : ajouter ou soustraire des dates  --ex: SELECT pseudo, message, DATE_ADD(date, INTERVAL 2 MONTH) AS date_expiration FROM minichat --rajoute 2 mois au temps des entrées dates
CURRENT_TIMESTAMP : renvoie date et heure actuelle
